"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertFromDirectory = exports.writeIndexFile = exports.getTypeFileNameFromSchema = exports.convertSchema = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const parse_1 = require("./parse");
const convertFilesInDirectory_1 = require("./convertFilesInDirectory");
const writeInterfaceFile_1 = require("./writeInterfaceFile");
/**
 * Apply defaults to the Partial Settings parameter
 *
 * @param settings Partial Setting object
 * @returns Complete Settings object
 */
function defaultSettings(settings) {
    const appSettings = Object.assign({
        defaultToRequired: false,
        schemaFileSuffix: 'Schema',
        debug: false,
        fileHeader: `/**
 * This file was automatically generated by joi-to-typescript
 * Do not modify this file manually
 */`,
        sortPropertiesByName: true,
        commentEverything: false,
        ignoreFiles: []
    }, settings);
    return appSettings;
}
function convertSchema(settings, joi, exportedName) {
    var _a;
    const details = joi.describe();
    const name = ((_a = details === null || details === void 0 ? void 0 : details.flags) === null || _a === void 0 ? void 0 : _a.label) || exportedName;
    if (!name) {
        throw new Error(`At least one "object" does not have a .label(). Details: ${JSON.stringify(details)}`);
    }
    if (settings.debug && name.toLowerCase().endsWith('schema')) {
        console.debug(`It is recommended you update the Joi Schema '${name}' similar to: ${name} = Joi.object().label('${name.replace('Schema', '')}')`);
    }
    // Set the label from the exportedName if missing
    if (!details.flags) {
        details.flags = { label: name };
    }
    else if (!details.flags.label) {
        // Unable to build any test cases for this line but will keep it if joi.describe() changes
        /* istanbul ignore next */
        details.flags.label = name;
    }
    const parsedSchema = parse_1.parseSchema(details, settings, false);
    if (parsedSchema) {
        const customTypes = parse_1.getAllCustomTypes(parsedSchema);
        const content = parse_1.typeContentToTs(settings, parsedSchema, true);
        return {
            name,
            customTypes,
            content
        };
    }
    // The only type that could return this is alternatives
    // see parseAlternatives for why this is ignored
    /* istanbul ignore next */
    return undefined;
}
exports.convertSchema = convertSchema;
function getTypeFileNameFromSchema(schemaFileName, settings) {
    return schemaFileName.endsWith(`${settings.schemaFileSuffix}.ts`)
        ? schemaFileName.substring(0, schemaFileName.length - `${settings.schemaFileSuffix}.ts`.length)
        : schemaFileName.replace('.ts', '');
}
exports.getTypeFileNameFromSchema = getTypeFileNameFromSchema;
/**
 * Write index.ts file
 *
 * @param settings - Settings Object
 * @param fileNamesToExport - List of file names that will be added to the index.ts file
 */
function writeIndexFile(settings, fileNamesToExport) {
    if (fileNamesToExport.length === 0) {
        // Don't write an index file if its going to export nothing
        return;
    }
    const exportLines = fileNamesToExport.map(fileName => `export * from './${fileName.replace(/\\/g, '/')}';`);
    const fileContent = `${settings.fileHeader}\n\n${exportLines.join('\n').concat('\n')}`;
    fs_1.writeFileSync(path_1.default.join(settings.typeOutputDirectory, 'index.ts'), fileContent);
}
exports.writeIndexFile = writeIndexFile;
/**
 * Create types from schemas from a directory
 *
 * @param settings - Configuration settings
 * @returns The success or failure of this operation
 */
async function convertFromDirectory(settings) {
    const appSettings = defaultSettings(settings);
    const filesInDirectory = await convertFilesInDirectory_1.convertFilesInDirectory(appSettings, path_1.default.resolve(appSettings.typeOutputDirectory));
    if (!filesInDirectory.types || filesInDirectory.types.length === 0) {
        throw new Error('No schemas found, cannot generate interfaces');
    }
    for (const exportType of filesInDirectory.types) {
        writeInterfaceFile_1.writeInterfaceFile(appSettings, exportType.typeFileName, filesInDirectory.types);
    }
    if (appSettings.indexAllToRoot || appSettings.flattenTree) {
        // Write index.ts
        writeIndexFile(appSettings, filesInDirectory.typeFileNames);
    }
    return true;
}
exports.convertFromDirectory = convertFromDirectory;
